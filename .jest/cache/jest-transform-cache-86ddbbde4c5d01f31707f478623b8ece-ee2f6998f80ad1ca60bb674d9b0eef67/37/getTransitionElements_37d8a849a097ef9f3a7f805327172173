8ccc82ad8b038aa26aa9f9409b973bff
"use strict";var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.getTransitionElements = exports.getCalculatedTransitionStyle = void 0;var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");

var _Utils = require("../Utils");
var _TransitionTypes = require("./TransitionTypes");
var Constants = _interopRequireWildcard(require("../TransitionConstants"));
var _TransitionItem = _interopRequireDefault(require("../TransitionItem"));

var _Types = require("../Types");






var getTransitionElements = function getTransitionElements(transitionElements,
transitionContext) {return transitionElements.map(function (item, idx) {
    var routeDirection = transitionContext.getDirectionForRoute(item.name, item.route);
    var element = _react.default.Children.only(item.reactElement.props.children);
    var key = "ti-" + idx.toString();

    var transitionStyle = getComponentStyle(
    item, routeDirection === _Types.RouteDirection.from ?
    transitionContext.delayCountFrom + 1 : transitionContext.delayCountTo + 1,
    routeDirection === _Types.RouteDirection.from ?
    transitionContext.delayIndexFrom : transitionContext.delayIndexTo,
    transitionContext);


    var style = [transitionStyle, styles.transitionElement];
    var props = (0, _objectSpread2.default)({}, element.props, { __index: item.index });
    element = _react.default.createElement(element.type, (0, _objectSpread2.default)({}, props, { key: key }));
    var comp = (0, _Utils.createAnimatedWrapper)({ component: element, nativeStyles: style });

    if (item.delay) {
      if (routeDirection === _Types.RouteDirection.from) {
        transitionContext.delayIndexFrom += transitionContext.delayFromFactor;
      } else {
        transitionContext.delayIndexTo += transitionContext.delayToFactor;
      }
    }
    return comp;
  });};exports.getTransitionElements = getTransitionElements;

var getComponentStyle = function getComponentStyle(
item, delayCount, delayIndex,
transitionContext)
{
  var index = transitionContext.getIndex();
  var routeDirection = transitionContext.getDirectionForRoute(item.name, item.route);
  var progress = transitionContext.getTransitionProgress();
  var routes = transitionContext.getRoutes();

  var transitionStyle = progress ? getCalculatedTransitionStyle(
  item,
  delayCount,
  delayIndex,
  index,
  routeDirection,
  progress,
  routes.length === 1) :
  {};

  var resolvedMetrics = (0, _Utils.getResolvedMetrics)(item, item.metrics);
  return (0, _objectSpread2.default)({
    left: resolvedMetrics.x,
    top: resolvedMetrics.y,
    width: resolvedMetrics.width,
    height: resolvedMetrics.height },
  transitionStyle);

};

var getCalculatedTransitionStyle = function getCalculatedTransitionStyle(
item,
delayCount,
delayIndex,
index,
routeDirection,
progress,
singleRoute)
{
  var transitionFunction = getTransitionFunction(item, routeDirection);
  if (transitionFunction) {

    var start = Constants.TRANSITION_PROGRESS_START;
    var end = Constants.TRANSITION_PROGRESS_END;

    var distance = !singleRoute ?
    (1.0 - (Constants.TRANSITION_PROGRESS_START + (
    1.0 - Constants.TRANSITION_PROGRESS_END))) * 0.5 :
    1.0 - (Constants.TRANSITION_PROGRESS_START + (
    1.0 - Constants.TRANSITION_PROGRESS_END));

    if (item.delay) {

      var delayStep = distance / delayCount;
      if (routeDirection === _Types.RouteDirection.from) {
        start += delayStep * delayIndex;
      } else {
        end -= delayStep * delayIndex;
      }
    } else if (!singleRoute) {

      if (routeDirection === _Types.RouteDirection.to) {
        start += distance;
      } else {
        end -= distance;
      }
    }




    var interpolatedProgress = progress.interpolate({
      inputRange: [index - 1, index, index + 1],
      outputRange: [0, 1, 0] });


    var transitionSpecification = {
      progress: interpolatedProgress,
      name: item.name,
      route: item.route,
      metrics: item.metrics,
      boundingbox: item.boundingBoxMetrics,
      direction: routeDirection,
      dimensions: _reactNative.Dimensions.get('window'),
      start: start,
      end: end };


    return transitionFunction(transitionSpecification);
  }

  return {};
};exports.getCalculatedTransitionStyle = getCalculatedTransitionStyle;

var getTransitionFunction = function getTransitionFunction(item, routeDirection) {
  var getTransition = function getTransition(transition) {
    if (transition instanceof Function) {return transition;}
    return (0, _TransitionTypes.getTransitionType)(transition);
  };

  if (routeDirection === _Types.RouteDirection.to && item.appear) {
    return getTransition(item.appear);
  }if (routeDirection === _Types.RouteDirection.from && item.disappear) {
    return getTransition(item.disappear);
  }if (item.appear) {
    return getTransition(item.appear);
  }
  return null;
};

var styles = _reactNative.StyleSheet.create({
  transitionElement: {
    position: 'absolute' } });