c21075a6e455e0bef8ec624ba39596dc
"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.createAnimated = exports.createAnimatedWrapper = void 0;var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");

var _getRotationFromStyle = require("./getRotationFromStyle");
var _mergeStyles = require("./mergeStyles");var _jsxFileName = "/Users/jdnichollsc/dev/react-native/Randomuser-me/node_modules/react-navigation-fluid-transitions/Utils/createAnimatedWrapper.js";


















































var createAnimatedWrapper = function createAnimatedWrapper(params) {
  var equalAspectRatio = params.equalAspectRatio === undefined ? true : params.equalAspectRatio;


  var nativeAnimatedComponent = params.nativeCached || createAnimated();
  var animatedComponent = params.cached || createAnimated();


  var flattenedStyle = _reactNative.StyleSheet.flatten(params.component.props.style);


  var nativeAnimatedStyles = getNativeAnimatableStyles(flattenedStyle);
  var animatedStyles = getAnimatableStyles(flattenedStyle);
  var componentStyles = getResolvedAspectRatio(equalAspectRatio, true,
  getComponentStyles(flattenedStyle));


  var innerElement = _react.default.createElement(params.component.type, (0, _objectSpread2.default)({},
  params.component.props, {
    ref: params.innerRef,
    style: [componentStyles, getDebugBorder('#F00')] }));



  var additionalAnimatedStyles = { overflow: 'hidden' };



  if (nativeAnimatedStyles &&
  nativeAnimatedStyles.position === 'absolute') {
    additionalAnimatedStyles.flex = 1;
  }


  var finalAnimatedStyles = [
  animatedStyles,
  params.styles,
  additionalAnimatedStyles,
  getDebugBorder('#0F0')];


  var animatedElement = _react.default.createElement(
  animatedComponent, { style: finalAnimatedStyles },
  innerElement);



  var finalNativeAnimatedStyles = getResolvedRotation([].concat((0, _toConsumableArray2.default)(
  getStylesWithMergedTransforms([].concat((0, _toConsumableArray2.default)(
  params.nativeStyles ? params.nativeStyles : []), [
  nativeAnimatedStyles]))), [

  getDebugBorder('#00F'),
  params.overrideStyles]));



  var props = {
    collapsable: false,
    style: getResolvedAspectRatio(equalAspectRatio, false, finalNativeAnimatedStyles) };



  if (params.component.props.__index) {
    props = (0, _objectSpread2.default)({}, props, { index: parseInt(params.component.props.__index, 10) });
  }
  if (params.component.key) {props = (0, _objectSpread2.default)({}, props, { key: params.component.key });}
  if (params.component.ref) {props = (0, _objectSpread2.default)({}, props, { ref: params.component.ref });}
  if (params.component.onLayout) {props = (0, _objectSpread2.default)({}, props, { onLayout: params.component.onLayout });}


  var nativeAnimatedElement = _react.default.createElement(
  nativeAnimatedComponent,
  props,
  animatedElement);















  return nativeAnimatedElement;
};exports.createAnimatedWrapper = createAnimatedWrapper;


var createAnimated = function createAnimated() {

  var wrapper = _react.default.createElement(_reactNative.View, { __source: { fileName: _jsxFileName, lineNumber: 152 } });
  return _reactNative.Animated.createAnimatedComponent(wrapper.type);
};exports.createAnimated = createAnimated;

var getDebugBorder = function getDebugBorder() {return {};};

var getResolvedAspectRatio = function getResolvedAspectRatio(equalAspectRatio,
addFlex, style) {
  if (!style || equalAspectRatio) return style;
  var retVal = !(style instanceof Array) ? [(0, _objectSpread2.default)({}, style)] : style.map(function (s) {return (0, _objectSpread2.default)({}, s);});
  retVal.forEach(function (r) {

    delete r.width;
    delete r.height;
  });
  if (!addFlex) return retVal;
  return [].concat((0, _toConsumableArray2.default)(retVal), [{ flex: 1 }]);
};

var getResolvedRotation = function getResolvedRotation(styles) {

  var stylesCopy = styles.filter(function (i) {return i;}).map(function (s) {
    if (!s) return null;
    if (isNumber(s)) return s;
    var sc = (0, _objectSpread2.default)({}, s);
    if (sc.transform) {
      sc.transform = (0, _toConsumableArray2.default)(s.transform);
      sc.transform = sc.transform.map(function (t) {return (0, _objectSpread2.default)({}, t);});
    }
    return sc;
  });
  var a = new _reactNative.Animated.Value(0);
  stylesCopy.forEach(function (style) {
    if (style && style.transform) {
      var ri = (0, _getRotationFromStyle.getRotationFromStyle)(style);
      if (ri.rotate) {
        if (ri.rotate.rotate && typeof ri.rotate.rotate === 'string') {
          style.transform.find(function (t) {return Object.keys(t)[0] === 'rotate';}).rotate = a.interpolate({ inputRange: [0, 1],
            outputRange: [ri.rotate.rotate, '0deg'] });
        }

        if (ri.rotate.rotateX && typeof ri.rotate.rotateX === 'string') {
          style.transform.find(function (t) {return Object.keys(t)[0] === 'rotateX';}).rotateX = a.interpolate({ inputRange: [0, 1],
            outputRange: [ri.rotateX.rotateX, '0deg'] });
        }

        if (ri.rotate.rotateY && typeof ri.rotate.rotateY === 'string') {
          style.transform.find(function (t) {return Object.keys(t)[0] === 'rotateY';}).rotateY = a.interpolate({ inputRange: [0, 1],
            outputRange: [ri.rotateY.rotateY, '0deg'] });
        }
      }
    }
  });

  return stylesCopy;
};

var getStylesWithMergedTransforms = function getStylesWithMergedTransforms(
styles)
{
  var retVal = [];
  var transforms = [];
  if (styles) {
    styles.forEach(function (s) {
      if (s) {
        if (s.transform) {
          var t = s.transform;
          delete s.transform;
          t.forEach(function (ti) {
            if (!transforms.find(function (el) {return Object.keys(el)[0] === Object.keys(ti)[0];})) {transforms.push(ti);}
          });
        }
        retVal.push(s);
      }
    });
    retVal.push({ transform: transforms });
    return retVal;
  }

  return styles;
};

var getNativeAnimatableStyles = function getNativeAnimatableStyles(
styles) {return (
    getFilteredStyle(styles, function (key) {return includePropsForNativeStyles.indexOf(key) > -1;}));};

var getAnimatableStyles = function getAnimatableStyles(
styles) {return (
    getFilteredStyle(styles, function (key) {return validStyles.indexOf(key) > -1 &&
      excludePropsForStyles.indexOf(key) === -1;}));};

var getComponentStyles = function getComponentStyles(
styles) {return (
    getFilteredStyle(styles, function (key) {return excludePropsForComponent.indexOf(key) === -1;}));};

var getFilteredStyle = function getFilteredStyle(
styles,
shouldIncludeKey)
{
  if (!styles) return styles;
  var flattenedStyle = styles;
  if (!(styles instanceof Object)) {
    flattenedStyle = _reactNative.StyleSheet.flatten(styles);
  }

  if (!flattenedStyle) return styles;
  if (!(flattenedStyle instanceof Array)) {
    flattenedStyle = [flattenedStyle];
  }

  var retVal = {};
  flattenedStyle.forEach(function (s) {
    if (s) {
      var keys = Object.keys(s);
      keys.forEach(function (key) {
        if (!isNumber(key) && shouldIncludeKey(key)) {
          retVal[key] = s[key];
        }
      });
    }
  });

  return retVal;
};

function isNumber(n) {return !Number.isNaN(parseFloat(n)) && !Number.isNaN(n - 0);}

var paddingStyles = [
'padding',
'paddingVertical',
'paddingHorizontal',
'paddingTop',
'paddingBottom',
'paddingLeft',
'paddingRight',
'paddingStart',
'paddingEnd'];


var marginStyles = [
'margin',
'marginVertical',
'marginHorizontal',
'marginTop',
'marginBottom',
'marginLeft',
'marginRight',
'marginStart',
'marginEnd'];


var borderStyles = [
'borderColor',
'borderTopColor',
'borderRightColor',
'borderBottomColor',
'borderLeftColor',
'borderStartColor',
'borderEndColor',
'borderRadius',
'borderTopLeftRadius',
'borderTopRightRadius',
'borderTopStartRadius',
'borderTopEndRadius',
'borderBottomLeftRadius',
'borderBottomRightRadius',
'borderBottomStartRadius',
'borderBottomEndRadius',
'borderStyle',
'borderWidth',
'borderLeftWidth',
'borderRightWidth',
'borderBottomWidth',
'borderTopWidth'];


var positionStyles = [
'start',
'end',
'top',
'left',
'right',
'bottom',
'minWidth',
'maxWidth',
'minHeight',
'maxHeight'];


var shadowStyles = [
'shadowColor',
'shadowOffset',
'shadowOpacity',
'shadowRadius',
'elevation'];


var excludePropsForComponent = [].concat(
paddingStyles,
marginStyles,
borderStyles,
positionStyles,
shadowStyles, [
'display',


'position',
'flexWrap',

'flexGrow',
'flexShrink',
'flexBasis',
'alignSelf',
'aspectRatio',
'zIndex',
'direction',
'transform',
'transformMatrix',
'decomposedMatrix',
'scaleX',
'scaleY',
'rotation',
'translateX',
'translateY',
'backfaceVisibility',
'backgroundColor']);


var includePropsForNativeStyles = [].concat(
marginStyles,
positionStyles,
shadowStyles, [
'display',
'width',
'height',
'position',
'flexDirection',
'flexWrap',
'flex',
'flexGrow',
'flexShrink',
'flexBasis',
'alignSelf',
'aspectRatio',
'zIndex',
'direction',
'transform']);


var excludePropsForStyles = [].concat(
marginStyles,
positionStyles, [
'display',


'position',
'alignSelf',
'alignContent',
'overflow',
'flexGrow',
'flexShrink',
'flexBasis',
'aspectRatio',
'zIndex',
'direction',
'transform',
'transformMatrix',
'decomposedMatrix',
'scaleX',
'scaleY',
'rotation',
'translateX',
'translateY']);


var validStyles = [
'display',
'width',
'height'].concat(
positionStyles,
marginStyles,
paddingStyles,
borderStyles, [
'position',
'flexDirection',
'flexWrap',
'justifyContent',
'alignItems',
'alignSelf',
'alignContent',
'overflow',
'flex',
'flexGrow',
'flexShrink',
'flexBasis',
'aspectRatio',
'zIndex',
'direction',
'shadowColor',
'shadowOffset',
'shadowOpacity',
'shadowRadius',
'transform',
'transformMatrix',
'decomposedMatrix',
'scaleX',
'scaleY',
'rotation',
'translateX',
'translateY',
'backfaceVisibility',
'backgroundColor',
'opacity',
'elevation']);