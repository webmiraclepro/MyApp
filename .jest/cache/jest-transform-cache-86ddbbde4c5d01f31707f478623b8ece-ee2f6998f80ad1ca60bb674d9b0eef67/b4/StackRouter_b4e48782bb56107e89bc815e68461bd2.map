{"version":3,"sources":["StackRouter.js"],"names":["action","NavigationActions","StackActions","defaultActionCreators","stackConfig","childRouters","routeNames","Object","routeConfig","routeConfigs","screen","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","route","childRouter","behavesLikePushAction","childState","childAction","params","key","isTransitioning","index","routes","routeName","initialRouteKey","getPathAndParamsForRoute","getActionForPathAndParams","getComponentForState","activeChildRoute","state","getComponentForRouteName","getActionCreators","pop","n","popToTop","push","replace","newKey","reset","actions","dismiss","getStateForAction","getInitialState","isResetToRootStack","activeChildRouter","StateUtils","childRoute","nextRouteState","newState","lastRouteIndex","r","getParamsForRouteAndAction","childRouterNames","i","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","routeIndex","lastRoute","newStackActions","router","newStackAction","immediate","backRouteIndex","Math","backRoute","keyIndex","getPathAndParamsForState","getScreenOptions"],"mappings":"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","sourcesContent":["import * as NavigationActions from '../NavigationActions';\nimport * as StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = () => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach(routeName => {\n    const routeConfig = routeConfigs[routeName];\n    const screen =\n      routeConfig && routeConfig.screen ? routeConfig.screen : routeConfig;\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (routeConfigs[initialRouteName].params ||\n      route.params ||\n      action.params ||\n      initialRouteParams) && {\n      ...(routeConfigs[initialRouteName].params || {}),\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || (initialRouteKey || generateKey()),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...action.params };\n    } else {\n      return action.params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: params => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(\n            action,\n            activeChildRoute\n          );\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(\n              state,\n              activeChildRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS\n            );\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n              return {\n                ...newState,\n                isTransitioning:\n                  state.index !== newState.index\n                    ? action.immediate !== true\n                    : state.isTransitioning,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle push and navigate actions. This must happen after the focused\n      // child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex(r => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        // An instance of this route exists already and we're dealing with a navigate action\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          // Delegate to the child router with the given action, or init it\n          const childAction =\n            action.action ||\n            NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action),\n            });\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // note(brentvatne): does it make sense to wipe out the params\n            // here? or even to add params at all? need more info about what\n            // this solves\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          // Create the route from scratch\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return {\n                ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex;\n\n        // If the key param is undefined, set the index to the last route in the stack\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(r => r.key === action.key);\n        }\n\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                params: getParamsForRouteAndAction(action.routeName, action),\n              });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        action.toChildKey === state.routes[state.index].key &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key != state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({\n                  params: getParamsForRouteAndAction(\n                    newStackAction.routeName,\n                    newStackAction\n                  ),\n                });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: getParamsForRouteAndAction(\n                newStackAction.routeName,\n                newStackAction\n              ),\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate } = action;\n        let backRouteIndex = state.index;\n        if (action.type === StackActions.POP && n != null) {\n          // determine the index to go back *from*. In this case, n=1 means to go\n          // back from state.index, as if it were a normal \"BACK\" action\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (key) {\n          const backRoute = state.routes.find(route => route.key === key);\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true,\n          };\n        }\n      }\n\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        }\n        // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n        let childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(\n              state,\n              childRoute.key,\n              route,\n              // People don't expect these actions to switch the active route\n              // TODO: We should switch to action.preserveFocus: true for drawer in future\n              action.preserveFocus || action.type.includes('DRAWER')\n            );\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.defaultNavigationOptions\n    ),\n  };\n};\n"]}