{"version":3,"sources":["getChildEventSubscriber.js"],"names":["initialLastFocusEvent","actionSubscribers","willFocusSubscribers","didFocusSubscribers","willBlurSubscribers","didBlurSubscribers","refocusSubscribers","removeAll","set","upstreamSubscribers","subs","getChildSubscribers","emit","payloadWithType","type","subscribers","lastFocusEvent","upstreamEvents","addListener","eventName","state","lastState","action","payload","lastRoutes","routes","focusKey","isChildFocused","lastRoute","route","newRoute","childPayload","context","key","isTransitioning","previouslylastFocusEvent","remove","console"],"mappings":"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","sourcesContent":["/*\n * This is used to extract one children's worth of events from a stream of navigation action events\n *\n * Based on the 'action' events that get fired for this navigation state, this utility will fire\n * focus and blur events for this child\n */\nexport default function getChildEventSubscriber(\n  addListener,\n  key,\n  initialLastFocusEvent = 'didBlur'\n) {\n  const actionSubscribers = new Set();\n  const willFocusSubscribers = new Set();\n  const didFocusSubscribers = new Set();\n  const willBlurSubscribers = new Set();\n  const didBlurSubscribers = new Set();\n  const refocusSubscribers = new Set();\n\n  const removeAll = () => {\n    [\n      actionSubscribers,\n      willFocusSubscribers,\n      didFocusSubscribers,\n      willBlurSubscribers,\n      didBlurSubscribers,\n      refocusSubscribers,\n    ].forEach(set => set.clear());\n\n    upstreamSubscribers.forEach(subs => subs && subs.remove());\n  };\n\n  const getChildSubscribers = evtName => {\n    switch (evtName) {\n      case 'action':\n        return actionSubscribers;\n      case 'willFocus':\n        return willFocusSubscribers;\n      case 'didFocus':\n        return didFocusSubscribers;\n      case 'willBlur':\n        return willBlurSubscribers;\n      case 'didBlur':\n        return didBlurSubscribers;\n      case 'refocus':\n        return refocusSubscribers;\n      default:\n        return null;\n    }\n  };\n\n  const emit = (type, payload) => {\n    const payloadWithType = { ...payload, type };\n    const subscribers = getChildSubscribers(type);\n    subscribers &&\n      subscribers.forEach(subs => {\n        subs(payloadWithType);\n      });\n  };\n\n  // lastFocusEvent keeps track of focus state for one route. First we assume\n  // we are blurred. If we are focused on initialization, the first 'action'\n  // event will cause onFocus+willFocus events because we had previously been\n  // considered blurred\n  let lastFocusEvent = initialLastFocusEvent;\n\n  const upstreamEvents = [\n    'willFocus',\n    'didFocus',\n    'willBlur',\n    'didBlur',\n    'refocus',\n    'action',\n  ];\n\n  const upstreamSubscribers = upstreamEvents.map(eventName =>\n    addListener(eventName, payload => {\n      if (eventName === 'refocus') {\n        emit(eventName, payload);\n        return;\n      }\n\n      const { state, lastState, action } = payload;\n      const lastRoutes = lastState && lastState.routes;\n      const routes = state && state.routes;\n\n      // const lastFocusKey =\n      //   lastState && lastState.routes && lastState.routes[lastState.index].key;\n      const focusKey = routes && routes[state.index].key;\n\n      const isChildFocused = focusKey === key;\n      const lastRoute =\n        lastRoutes && lastRoutes.find(route => route.key === key);\n      const newRoute = routes && routes.find(route => route.key === key);\n      const childPayload = {\n        context: `${key}:${action.type}_${payload.context || 'Root'}`,\n        state: newRoute,\n        lastState: lastRoute,\n        action,\n        type: eventName,\n      };\n      const isTransitioning = !!state && state.isTransitioning;\n\n      const previouslylastFocusEvent = lastFocusEvent;\n\n      if (lastFocusEvent === 'didBlur') {\n        // The child is currently blurred. Look for willFocus conditions\n        if (eventName === 'willFocus' && isChildFocused) {\n          emit((lastFocusEvent = 'willFocus'), childPayload);\n        } else if (eventName === 'action' && isChildFocused) {\n          emit((lastFocusEvent = 'willFocus'), childPayload);\n        }\n      }\n      if (lastFocusEvent === 'willFocus') {\n        // We are currently mid-focus. Look for didFocus conditions.\n        // If state.isTransitioning is false, this child event happens immediately after willFocus\n        if (eventName === 'didFocus' && isChildFocused && !isTransitioning) {\n          emit((lastFocusEvent = 'didFocus'), childPayload);\n        } else if (\n          eventName === 'action' &&\n          isChildFocused &&\n          !isTransitioning\n        ) {\n          emit((lastFocusEvent = 'didFocus'), childPayload);\n        }\n      }\n\n      if (lastFocusEvent === 'didFocus') {\n        // The child is currently focused. Look for blurring events\n        if (!isChildFocused) {\n          // The child is no longer focused within this navigation state\n          emit((lastFocusEvent = 'willBlur'), childPayload);\n        } else if (eventName === 'willBlur') {\n          // The parent is getting a willBlur event\n          emit((lastFocusEvent = 'willBlur'), childPayload);\n        } else if (\n          eventName === 'action' &&\n          previouslylastFocusEvent === 'didFocus'\n        ) {\n          // While focused, pass action events to children for grandchildren focus\n          emit('action', childPayload);\n        }\n      }\n\n      if (lastFocusEvent === 'willBlur') {\n        // The child is mid-blur. Wait for transition to end\n        if (eventName === 'action' && !isChildFocused && !isTransitioning) {\n          // The child is done blurring because transitioning is over, or isTransitioning\n          // never began and didBlur fires immediately after willBlur\n          emit((lastFocusEvent = 'didBlur'), childPayload);\n        } else if (eventName === 'didBlur') {\n          // Pass through the parent didBlur event if it happens\n          emit((lastFocusEvent = 'didBlur'), childPayload);\n        } else if (\n          eventName === 'action' &&\n          isChildFocused &&\n          !isTransitioning\n        ) {\n          emit((lastFocusEvent = 'didFocus'), childPayload);\n        } else if (\n          eventName === 'action' &&\n          isChildFocused &&\n          isTransitioning\n        ) {\n          emit((lastFocusEvent = 'willFocus'), childPayload);\n        }\n      }\n\n      if (lastFocusEvent === 'didBlur' && !newRoute) {\n        removeAll();\n      }\n    })\n  );\n\n  return {\n    addListener(eventName, eventHandler) {\n      const subscribers = getChildSubscribers(eventName);\n      if (!subscribers) {\n        throw new Error(`Invalid event name \"${eventName}\"`);\n      }\n      subscribers.add(eventHandler);\n      const remove = () => {\n        subscribers.delete(eventHandler);\n      };\n      return { remove };\n    },\n    emit(eventName, payload) {\n      if (eventName !== 'refocus') {\n        console.error(\n          `navigation.emit only supports the 'refocus' event currently.`\n        );\n        return;\n      }\n      emit(eventName, payload);\n    },\n  };\n}\n"]}